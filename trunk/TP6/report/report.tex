\documentclass{article}

\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{cite}
\usepackage{url}
\usepackage{amsmath}

\newcounter{qcounter}

\begin{document}

\title{Image Analysis - TP6 - Background Subtraction}

\author{Jander Nascimento, 
\and Raquel Oliveira}

\maketitle

\section{Introduction}

The goal of segmentation is to simplify and/or change the representation of an image into something that is more meaningful and easier to analyze. Image segmentation is the process of assigning a label to every pixel in an image such that pixels with the same label share certain visual characteristics.\cite{introduction}

Segmentation is mostly used for object recognition, differentiate those objects from the background, image compression or image editing.

In this practical work, we implemented an approach for image segmentation with the purpose of background subtraction, with which is possible to identify the foreground region in an image given a set of images of the background.


\section{The method}

In this exercise we use a Gaussian model to build a statistical model of the background for each pixel in the image. For each colored pixel \textit{i}, i.e., \textit{i=($i_r, i_g, i_b$)}, the associated color probability density writes:

	\begin{figure} [H]
		\centering
		\includegraphics[scale=0.5]{img/formula}
		\caption{Gaussian model\label{formula}}
	\end{figure}

We implemented this formula step by step, first creating all the methods that would be useful to generate the model, as subtraction and multiplication between matrices; transpose, inverse and determinant of a matrix and the covariance matrix.

We calculate the mean matrix once, in the beginning of the method. Over there we stored the mean value for each pixel (\textit{$i_m$} in the formula above) with respect to their colors in all the background images considered.

With the previous methods was possible to build the Gaussian model for all pixels in the images in the background. We were given 115 images of the static background, to build the model (Figure \ref{background}).

	\begin{figure} [H]
		\centering
		\includegraphics[scale=0.3]{img/img_000000}
		\caption{Example of background\label{background}}
	\end{figure}


\section{Results}
	We tested the statical model with the 5 given foreground images. For each pixel, based on the model, we can determine if the pixel belongs either to a foreground or to a background of the image.

	Given an input image with a foreground, we create a binary image with two regions: foreground and background. What determines which region the pixel belongs to is the probability given by the Gaussian model. To do so, it is needed to threshold the probability for each pixel.

	The probability that a pixel belongs to a background is given by the formula described in Figure \ref{formula}. And the probability that a pixel belongs to a foreground is:

	\begin{equation}
	 p_f(i)=1-p_b(i)  
	\end{equation}

	We tested some thresholds to determine which one would be more suitable to properly distribute the pixels in the 2 regions, and the value that gave better results was 0.01. So, if {$p_b(i)>0,01$}, means that the pixel belongs to the background (which we painted in black). Otherwise, it belongs to the foreground (which we painted in white). 

	We can see in Figure \ref{fig:img_000053} the results of the algorithm for a image with a foreground. To obtain this result, all the 115 background images were used to built the statistical model.

	\begin{figure}[H]
		  \centering
		  \subfloat[Original Image]{\includegraphics[width=0.5\textwidth]{img/img_000053}}                
		  \subfloat[Binary Image]{\includegraphics[width=0.5\textwidth]{img/result_53_115}}
		  \caption{Background Subtraction}
		  \label{fig:img_000053}
	\end{figure}

\subsection{Effect of the threshold}

\subsection{Effect of the number of background images}

	We observed that the more static background images you use to build the statistical model, the better the result is. Which means that the pixels will be more correctly classified in their segments. We ilustrate this in the Figure \ref{fig:nback}, with different number of background images being used (denoted by N). 

	\begin{figure}[H]
		  \centering
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/img_000053}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_53_5}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_53_15}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_53_115}}
		  \hspace{0.1cm}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/img_000147}}                
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_147_5}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_147_15}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_147_115}}
		  \hspace{0.1cm}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/img_000348}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_348_5}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_348_15}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_348_115}}
		  \hspace{0.1cm}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/img_000466}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_466_5}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_466_15}}
		  \subfloat{\includegraphics[width=0.3\textwidth]{img/result_466_115}}
		  \hspace{0.1cm}
		  \subfloat[Original Image]{\includegraphics[width=0.3\textwidth]{img/img_000476}}
		  \subfloat[Binary Image N=5]{\includegraphics[width=0.3\textwidth]{img/result_476_5}}
		  \subfloat[N=15]{\includegraphics[width=0.3\textwidth]{img/result_476_15}}
		  \subfloat[N=115]{\includegraphics[width=0.3\textwidth]{img/result_476_115}}
		  \caption{Effect of the number of background images (N)}
		  \label{fig:nback}
	\end{figure}
	


\section{Issues}
	This method consumes much memory. In order to build the Gaussian model, for each pixel of the foreground image all the background images are read, and each background is an image with dimensions 1224x1624, which ends in 1.987.776 pixels in memory for one image. Since we use all the 115 background images, in the end of the day it is necessary to keep in memory 228.594.240 pixels!

	As a consequence, the time to separate foreground and background is very high. The standard implementation we have done so far to read ppm images was too slow to apply this method. Our read method by default reads an image and stores its pixels in a matrix, which we can use for any computation.

	To solve both problems of memory requirement and computation time, we changed our read image method to open a file and read the RGB values of only one pixel, instead of read and store all the pixels in a matrix. With that, was possible to apply the method and achieve the results describe above.

	This was possible just because we converted the given images in a binary format of PPM, instead of the original PNG format.



	limpar o codigo
	testar aplicando o blur antes
	colocar imagens de diferentes thresholds



\section{How to run?}

	Steps to compile the application:
	
	\begin{itemize}
		\item svn checkout https://jfimageanalysis.googlecode.com/svn/trunk/TP6/ \#download source code
		\item make \#compiles the code
	\end{itemize}


	Example of usage:

	\begin{itemize}
		\item ./tp6
	\end{itemize}

	The resulting images will be printed in the standard output.


\begin{thebibliography}{9}

\bibitem{introduction}
	Linda G. Shapiro and George C. Stockman
 	\emph{Computer Vision}.
	pp 279-325, 
	New Jersey, Prentice-Hall, 
	ISBN 0-13-030796-3
 	2001.

\end{thebibliography}

\end{document}


